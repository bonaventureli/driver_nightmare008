/*-----------------------------------------------------------------------------
 * Name:    MP230_Nightmare.c
 * Purpose: MP230 Nightmare music player is for Nightmare for room1-room2
 * "www.ewoodpecker.cn" ETZ-MP230
 * Rev.:    1.00
 *----------------------------------------------------------------------------*/
/* Copyright (c) 2016/5/16 LIFEI
   ---------------------------------------------------------------------------*/

#include "ME007Y50H.H"

/*******************************
variable
********************************/
uint8_t TxBuffer[][5] = {
{0x55,0xAA,0x01,0x01,0x01},
{0x55,0xAA,0x01,0x01,0x01},
};

uint8_t TxBuffer_music[][10] = {
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x00,0xFF,0xE0,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x01,0xFF,0xD9,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x02,0xFF,0xD8,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x03,0xFF,0xD7,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x04,0xFF,0xD6,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x05,0xFF,0xD5,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x06,0xFF,0xD4,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x07,0xFF,0xD3,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x08,0xFF,0xD2,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x09,0xFF,0xD1,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x0A,0xFF,0xD0,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x0B,0xFF,0xCF,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x0C,0xFF,0xCE,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x0D,0xFF,0xCD,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x0E,0xFF,0xCC,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x0F,0xFF,0xCB,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x10,0xFF,0xCA,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x11,0xFF,0xC9,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x12,0xFF,0xC8,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x13,0xFF,0xC7,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x14,0xFF,0xC6,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x15,0xFF,0xC5,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x16,0xFF,0xC4,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x17,0xFF,0xC3,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x18,0xFF,0xC2,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x19,0xFF,0xC1,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x1A,0xFF,0xC0,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x1B,0xFF,0xBF,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x1C,0xFF,0xBE,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x1D,0xFF,0xBD,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x1E,0xFF,0xBC,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x1F,0xFF,0xBB,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x20,0xFF,0xBA,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x21,0xFF,0xB9,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x22,0xFF,0xB8,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x23,0xFF,0xB7,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x24,0xFF,0xB6,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x25,0xFF,0xB5,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x26,0xFF,0xB4,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x27,0xFF,0xB3,0xEF},
{0x7E,0x10,0x06,0x0f,0x00,0x01,0x28,0xFF,0xB2,0xEF},

};

uint8_t MusicOverBuffer[][10]={
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x00,0x7E,0x3E,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x01,0x7E,0x3D,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x02,0x7E,0x3C,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x03,0x7E,0x3B,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x04,0x7E,0x3A,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x05,0x7E,0x39,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x06,0x7E,0x38,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x07,0x7E,0x37,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x08,0x7E,0x36,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x09,0x7E,0x35,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x0A,0x7E,0x34,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x0B,0x7E,0x33,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x0C,0x7E,0x32,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x0D,0x7E,0x31,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x0E,0x7E,0x30,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x0F,0x7E,0x2F,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x10,0x7E,0x2E,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x11,0x7E,0x2D,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x12,0x7E,0x2C,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x13,0x7E,0x2B,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x14,0x7E,0x2A,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x15,0x7E,0x29,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x16,0x7E,0x28,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x17,0x7E,0x27,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x18,0x7E,0x26,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x19,0x7E,0x25,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x1A,0x7E,0x24,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x1B,0x7E,0x23,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x1C,0x7E,0x22,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x1D,0x7E,0x21,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x1E,0x7E,0x20,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x1F,0x7E,0x1F,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x20,0x7E,0x1E,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x21,0x7E,0x1D,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x22,0x7E,0x1C,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x23,0x7E,0x1B,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x24,0x7E,0x1A,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x25,0x7E,0x19,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x26,0x7E,0x18,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x27,0x7E,0x17,0x6F},
{0x7E,0x7F,0x06,0x3D,0x00,0x00,0x28,0x7E,0x16,0x6F},

};

uint8_t RxBuffer_music[10];
extern uint32_t Button_MASK_main;
extern uint8_t flag_button28;
__IO uint8_t TxCounter = 0,RxCounter = 0;
//__IO uint8_t TxxCounter = 24;
//uint8_t RxBuffer[InstructionLength];
uint8_t RxBuffer[7];
int32_t USARTx_Initialize (USART_TypeDef* USARTx);

/********************************
*@brif Initialize the MP230
*@para USARTx:USART1 USART2 USART3 UART4 UART5
*@return 0 
********************************/
int32_t MP230_Initialize (USART_TypeDef* USARTx) {
		USARTx_Initialize(USARTx);
  return 0;
}
/********************************
*@brif send one instruction
*@para USARTx:USART1 USART2 USART3 UART4 UART5
			 TempBufferLength: The length of the instructions
			 InstructionID: the instructions identifier
*@return none
********************************/
void SendOneInstructionA(USART_TypeDef* USARTx,\
												 uint16_t TempBufferLength,\
												 uint8_t InstructionID){
	/*Send one instruction*/
	uint8_t TempCounter = 0;
	while(TempCounter < TempBufferLength){
	/* Send one byte from USARTx */
	USART_SendData(USARTx, TxBuffer[InstructionID][TempCounter++]);
	/* Loop until USART1 DR register is empty */ 
	while(USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET){
	}
	}
	/*wait the return values from the Music modern*/
	RxCounter = 0;
	while(RxCounter < TempBufferLength){
	/* Loop until the USARTx Receive Data Register is not empty */
	while(USART_GetFlagStatus(USARTx, USART_FLAG_RXNE) == RESET){
	}
	/* Store the received byte in RxBuffer */
	RxBuffer[RxCounter++] = (USART_ReceiveData(USARTx) & 0x7F);
	}
}


/********************************
*@brif send one instruction
*@para USARTx:USART1 USART2 USART3 UART4 UART5
			 TempBufferLength: The length of the instructions
			 InstructionID: the instructions identifier
*@return return InstructionID, indate the music is over.
********************************/
uint8_t SendOneInstructionB(USART_TypeDef* USARTx,\
												 uint16_t TempBufferLength,\
												 uint8_t InstructionID){
	/*Send one instruction*/
	uint8_t TempCounter = 0;
	while(TempCounter < TempBufferLength){
	/* Send one byte from USARTx */
	USART_SendData(USARTx, TxBuffer[InstructionID][TempCounter++]);
	/* Loop until USART1 DR register is empty */ 
	while(USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET){
	}
	}
	/*wait the return values from the Music modern*/
	RxCounter = 0;
	while(RxCounter < TempBufferLength){
	/* Loop until the USARTx Receive Data Register is not empty */
	while(USART_GetFlagStatus(USARTx, USART_FLAG_RXNE) == RESET){
	}
	/* Store the received byte in RxBuffer */
	RxBuffer[RxCounter++] = (USART_ReceiveData(USARTx) & 0x7F);
	}
	return InstructionID;
}
												 
uint8_t SendOneInstructionB_music(USART_TypeDef* USARTx,\
												 uint16_t TempBufferLength,\
												 uint8_t InstructionID){
	/*Send one instruction*/
	uint8_t TempCounter = 0;
	while(TempCounter < TempBufferLength){
	/* Send one byte from USARTx */
	USART_SendData(USARTx, TxBuffer_music[InstructionID][TempCounter++]);
	/* Loop until USART1 DR register is empty */ 
	while(USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET){
	}
	}
	/*wait the return values from the Music modern*/
	RxCounter = 0;
	while(RxCounter < TempBufferLength){
	/* Loop until the USARTx Receive Data Register is not empty */
	while(USART_GetFlagStatus(USARTx, USART_FLAG_RXNE) == RESET){
	}
	/* Store the received byte in RxBuffer */
	RxBuffer_music[RxCounter++] = (USART_ReceiveData(USARTx) & 0x7F);
	}
	return InstructionID;
}
/********************************
*@brif send one instruction
*@para USARTx:USART1 USART2 USART3 UART4 UART5
			 TempBufferLength: The length of the instructions
			 InstructionID: the instructions identifier
*@return return InstructionID, indate the music is over.
********************************/
uint8_t SendInstruction(USART_TypeDef* USARTx,\
												 uint8_t InstructionID){
	/*Send one instruction*/
	uint8_t TempCounter = 0;
	while(TempCounter < 5){
	/* Send one byte from USARTx */
	USART_SendData(USARTx, TxBuffer[InstructionID][TempCounter++]);
	/* Loop until USART1 DR register is empty */ 
	while(USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET){
	}
	}
	/*wait the return values from the Music modern*/
	RxCounter = 0;
	while(RxCounter < 7){
	/* Loop until the USARTx Receive Data Register is not empty */
	while(USART_GetFlagStatus(USARTx, USART_FLAG_RXNE) == RESET){
	}
	/* Store the received byte in RxBuffer */
	RxBuffer[RxCounter++] = (USART_ReceiveData(USARTx) & 0xFF);
	}
	return InstructionID;
}
uint8_t SendOneInstructionB2(USART_TypeDef* USARTx,\
												 uint16_t TempBufferLength,\
												 uint8_t InstructionID){
	/*Send one instruction*/
	uint8_t TempCounter = 0;
	while(TempCounter < TempBufferLength){
	/* Send one byte from USARTx */
	USART_SendData(USARTx, TxBuffer[InstructionID][TempCounter++]);
	/* Loop until USART1 DR register is empty */ 
	while(USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET){
	}
	}
	/*wait the return values from the Music modern*/
	RxCounter = 0;
	flag_button28=0;
	while(RxCounter < TempBufferLength){
	/* Loop until the USARTx Receive Data Register is not empty */
	while(USART_GetFlagStatus(USARTx, USART_FLAG_RXNE) == RESET){
		if(flag_button28==1){break;}
	}
	/* Store the received byte in RxBuffer */
	RxBuffer[RxCounter++] = (USART_ReceiveData(USARTx) & 0x7F);
	}
	return InstructionID;
}

uint8_t* SendOneInstruction(USART_TypeDef* USARTx,\
	uint8_t TempTxBuffer[][10],\
	uint8_t TempRxBuffer[10],\
	uint16_t TempTxxCounter,\
	uint16_t TempBufferLength){
	//Send one instruction
	uint8_t TempTxCounter = 0;
	uint8_t TempRxCounter = 0;
	while(TempTxCounter < TempBufferLength){
	/* Send one byte from USARTx */
	USART_SendData(USARTx, TempTxBuffer[TempTxxCounter][TempTxCounter++]);
	/* Loop until USART1 DR register is empty */ 
	while(USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET){
	}
	}		 
	/*wait the return values from the Music modern*/
	TempRxCounter = 0;
	while(TempRxCounter < TempBufferLength){
	/* Loop until the USARTx Receive Data Register is not empty */
	while(USART_GetFlagStatus(USARTx, USART_FLAG_RXNE) == RESET){
	}
	/* Store the received byte in RxBuffer */
	(TempRxBuffer[TempRxCounter++]) = (USART_ReceiveData(USARTx) & 0x7F);
	}
	return TempRxBuffer;
}

/********************************
*@brif Just send one instruction
*@para USARTx:USART1 USART2 USART3 UART4 UART5
			 TempBufferLength: The length of the instructions
			 InstructionID: the instructions identifier
*@return none
********************************/
void JustSendOneInstruction(USART_TypeDef* USARTx,\
												 uint16_t TempBufferLength,\
												 uint8_t InstructionID){
	/*Send one instruction*/
	uint8_t TempCounter = 0;
	while(TempCounter < TempBufferLength){
	/* Send one byte from USARTx */
	USART_SendData(USARTx, TxBuffer[InstructionID][TempCounter++]);
	/* Loop until USART1 DR register is empty */ 
	while(USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET){
	}
 }
}
